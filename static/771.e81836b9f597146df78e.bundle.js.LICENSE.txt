/*
       * @param {Array} baseLine a two-element array of latlng objects
       *   representing the baseline to project from
       * @param {Array} latLngs an array of latlng objects
       * @returns {Object} the maximum point and all new points to stay
       *   in consideration for the hull.
       */

/*
       * @param {Object} cpt a point to be measured from the baseline
       * @param {Array} bl the baseline, as represented by a two-element
       *   array of latlng objects.
       * @returns {Number} an approximate distance measure
       */

/*
       * Given a baseline, compute the convex hull of latLngs as an array
       * of latLngs.
       *
       * @param {Array} latLngs
       * @returns {Array}
       */

/*
       * Given an array of latlngs, compute a convex hull as an array
       * of latlngs
       *
       * @param {Array} latLngs
       * @returns {Array}
       */

/* .Input */

/* .Input.Wrapper */

/* .createControlComponent */

/* .millisecondsInHour */

/* .millisecondsInMinute */

/* .useInputProps */

/* .useLeafletContext */

/* @__PURE__ */

/* Box */

/* CONTEXT_VERSION */

/* LeafletContext */

/* LeafletProvider */

/* Popover */

/* Popover.Dropdown */

/* Popover.Target */

/* Text */

/* ["default"] */

/* binding */

/* createContainerComponent */

/* createControlComponent */

/* createControlHook */

/* createDivOverlayComponent */

/* createDivOverlayHook */

/* createElementHook */

/* createElementObject */

/* createEventHandler */

/* createLayerComponent */

/* createLayerHook */

/* createLeafComponent */

/* createLeafletContext */

/* createOverlayComponent */

/* createPathComponent */

/* createPathHook */

/* createSafeContext */

/* createStyles */

/* createTileLayerComponent */

/* extendContext */

/* harmony default export */

/* harmony export */

/* harmony import */

/* isElement */

/* reexport */

/* rem */

/* unused harmony export useMapEvent */

/* updateGridLayer */

/* useAttribution */

/* useComponentDefaultProps */

/* useDelayedHover */

/* useDidUpdate */

/* useEventHandlers */

/* useLayerLifecycle */

/* useLeafletContext */

/* usePathOptions */

/* withPane */

/*#__PURE__*/

/**
     * Assigns impossible bounding values so that the next extend entirely determines the new bounds.
     * This method avoids having to trash the previous L.LatLngBounds object and to create a new one, which is much slower for this class.
     * As long as the bounds are not extended, most other methods would probably fail, as they would with bounds initialized but not extended.
     * @private
     */

/**
     * Expands the latitude to Infinity (or -Infinity) if the input bounds reach the map projection maximum defined latitude
     * (in the case of Web/Spherical Mercator, it is 85.0511287798 / see https://en.wikipedia.org/wiki/Web_Mercator#Formulas).
     * Otherwise, the removeOutsideVisibleBounds option will remove markers beyond that limit, whereas the same markers without
     * this option (or outside MCG) will have their position floored (ceiled) by the projection and rendered at that limit,
     * making the user think that MCG "eats" them and never displays them again.
     * @param bounds L.LatLngBounds
     * @returns {L.LatLngBounds}
     * @private
     */

/**
     * Extracts individual (i.e. non-group) layers from a Layer Group.
     * @param group to extract layers from.
     * @param output {Array} in which to store the extracted layers.
     * @returns {*|Array}
     * @private
     */

/**
     * Implements the singleMarkerMode option.
     * @param layer Marker to re-style using the Clusters iconCreateFunction.
     * @returns {L.Icon} The newly created icon.
     * @private
     */

/**
     * Makes sure the cluster center is set. If not, uses the child center if it is a cluster, or the marker position.
     * @param child L.MarkerCluster|L.Marker that will be used as cluster center if not defined yet.
     * @private
     */

/**
     * Re-draws the icon of the supplied markers.
     * To be used in singleMarkerMode only.
     * @param layers Array(L.Marker)|Map(L.Marker) list of markers.
     * @private
     */

/**
     * Refreshes the icon of all "dirty" visible clusters.
     * Non-visible "dirty" clusters will be updated when they are added to the map.
     * @private
     */

/**
     * Removes a marker from all _gridUnclustered zoom levels, starting at the supplied zoom.
     * @param marker to be removed from _gridUnclustered.
     * @param z integer bottom start zoom level (included)
     * @private
     */

/**
     * Simply flags all parent clusters of the given markers as having a "dirty" icon.
     * @param layers Array(L.Marker)|Map(L.Marker) list of markers.
     * @private
     */

/**
     * Updates the given options in the marker's icon and refreshes the marker.
     * @param options map object of icon options.
     * @param directlyRefreshClusters boolean (optional) true to trigger
     * MCG.refreshClustersOf() right away with this single marker.
     * @returns {L.Marker}
     */

/**
     * Updates the icon of all clusters which are parents of the given marker(s).
     * In singleMarkerMode, also updates the given marker(s) icon.
     * @param layers L.MarkerClusterGroup|L.LayerGroup|Array(L.Marker)|Map(L.Marker)|
     * L.MarkerCluster|L.Marker (optional) list of markers (or single marker) whose parent
     * clusters need to be updated. If not provided, retrieves all child markers of this.
     * @returns {L.MarkerClusterGroup}
     */

/** @class */

/***/

// 0 -> always spiral; Infinity -> always circle

// CONCATENATED MODULE: ./node_modules/@mantine/core/esm/HoverCard/HoverCard.errors.js

// CONCATENATED MODULE: ./node_modules/@mantine/hooks/esm/use-disclosure/use-disclosure.js

// CONCATENATED MODULE: ./node_modules/@react-leaflet/core/lib/circle.js

// CONCATENATED MODULE: ./node_modules/@react-leaflet/core/lib/dom.js

// CONCATENATED MODULE: ./node_modules/@react-leaflet/core/lib/media-overlay.js

// CONCATENATED MODULE: ./node_modules/@wojtekmaj/date-utils/dist/esm/index.js

// CONCATENATED MODULE: ./node_modules/detect-element-overflow/dist/esm/index.js

// CONCATENATED MODULE: ./node_modules/get-user-locale/dist/esm/index.js

// CONCATENATED MODULE: ./node_modules/react-clock/dist/esm/Clock.js

// CONCATENATED MODULE: ./node_modules/react-clock/dist/esm/Hand.js

// CONCATENATED MODULE: ./node_modules/react-clock/dist/esm/HourMark.js

// CONCATENATED MODULE: ./node_modules/react-clock/dist/esm/Mark.js

// CONCATENATED MODULE: ./node_modules/react-clock/dist/esm/MinuteMark.js

// CONCATENATED MODULE: ./node_modules/react-clock/dist/esm/index.js

// CONCATENATED MODULE: ./node_modules/react-clock/dist/esm/shared/hourFormatter.js

// CONCATENATED MODULE: ./node_modules/react-clock/dist/esm/shared/propTypes.js

// CONCATENATED MODULE: ./node_modules/react-clock/node_modules/clsx/dist/clsx.m.js

// CONCATENATED MODULE: ./node_modules/react-time-picker/dist/esm/Divider.js

// CONCATENATED MODULE: ./node_modules/react-time-picker/dist/esm/TimeInput.js

// CONCATENATED MODULE: ./node_modules/react-time-picker/dist/esm/TimeInput/AmPm.js

// CONCATENATED MODULE: ./node_modules/react-time-picker/dist/esm/TimeInput/Hour12Input.js

// CONCATENATED MODULE: ./node_modules/react-time-picker/dist/esm/TimeInput/Hour24Input.js

// CONCATENATED MODULE: ./node_modules/react-time-picker/dist/esm/TimeInput/MinuteInput.js

// CONCATENATED MODULE: ./node_modules/react-time-picker/dist/esm/TimeInput/NativeInput.js

// CONCATENATED MODULE: ./node_modules/react-time-picker/dist/esm/TimeInput/SecondInput.js

// CONCATENATED MODULE: ./node_modules/react-time-picker/dist/esm/TimePicker.js

// CONCATENATED MODULE: ./node_modules/react-time-picker/dist/esm/index.js

// CONCATENATED MODULE: ./node_modules/react-time-picker/dist/esm/shared/dateFormatter.js

// CONCATENATED MODULE: ./node_modules/react-time-picker/dist/esm/shared/dates.js

// CONCATENATED MODULE: ./node_modules/react-time-picker/dist/esm/shared/utils.js

// CONCATENATED MODULE: ./node_modules/react-time-picker/node_modules/clsx/dist/clsx.m.js

// CONCATENATED MODULE: ./node_modules/update-input-width/dist/esm/index.js

// ESM COMPAT FLAG

// EXPORTS

// EXTERNAL MODULE: ./node_modules/@mantine/core/esm/Floating/use-delayed-hover.js

// EXTERNAL MODULE: ./node_modules/@mantine/core/esm/Popover/Popover.js

// EXTERNAL MODULE: ./node_modules/@mantine/styles/esm/theme/MantineProvider.js

// EXTERNAL MODULE: ./node_modules/@mantine/styles/esm/tss/create-styles.js

// EXTERNAL MODULE: ./node_modules/@mantine/utils/esm/create-event-handler/create-event-handler.js

// EXTERNAL MODULE: ./node_modules/@mantine/utils/esm/create-safe-context/create-safe-context.js

// EXTERNAL MODULE: ./node_modules/@mantine/utils/esm/is-element/is-element.js

// EXTERNAL MODULE: ./node_modules/@react-leaflet/core/lib/attribution.js

// EXTERNAL MODULE: ./node_modules/@react-leaflet/core/lib/component.js

// EXTERNAL MODULE: ./node_modules/@react-leaflet/core/lib/context.js

// EXTERNAL MODULE: ./node_modules/@react-leaflet/core/lib/element.js

// EXTERNAL MODULE: ./node_modules/@react-leaflet/core/lib/events.js

// EXTERNAL MODULE: ./node_modules/@react-leaflet/core/lib/pane.js

// EXTERNAL MODULE: ./node_modules/@react-leaflet/core/lib/path.js

// EXTERNAL MODULE: ./node_modules/lodash.memoize/index.js

// EXTERNAL MODULE: ./node_modules/react-dom/index.js

// EXTERNAL MODULE: ./node_modules/react/index.js

// Exports

// If L.DomUtil.TRANSITION is falsy, this option has no effect.

// If false, option animateAddingMarkers below has no effect.

// If minHour is 12 am/pm, user should be able to enter 12, 1, ..., 11.

// If you are adding individual markers set to true, if adding bulk markers leave false for massive performance gains.

// Internet Explorer still fires onFocus on disabled elements

// Make it possible to provide custom function to calculate spiderfy shape positions

// Make it possible to specify a polyline options on a spider leg

// Module

// Private methods for animated versions.

// Set to false to disable all animations (zoom and spiderfy).

// Setting this to false prevents the removal of any clusters outside of the viewpoint, which

// Should apply the current opacity and location to all elements so we can update them again for an animation

// This is only for showing validity when editing

// Toggling clock visibility resets values

// UNUSED EXPORTS: TimePicker

// When bulk adding layers, adds markers in chunks. Means addLayers may not add all the layers in the call, others will be loaded during setTimeouts

// at the end of each interval, give n milliseconds back to system/browser

// boundsToApplyTo: a L.LatLngBounds representing the bounds of what clusters to recurse in to

// eslint-disable-next-line jsx-a11y/click-events-have-key-events, jsx-a11y/no-static-element-interactions

// eslint-disable-next-line jsx-a11y/no-autofocus

// eslint-disable-next-line react/no-array-index-key

// is the default behaviour for performance reasons.

// pm is always after am, so we should ignore validation

// process markers for a maximum of ~ n milliseconds (then trigger the chunkProgress callback)

// progress callback: function(processed, total, elapsed) (e.g. for a progress indicator)

// runAtBottomLevel: function that takes an L.MarkerCluster as an argument that should be applied at only the bottom level

// runAtEveryLevel: function that takes an L.MarkerCluster as an argument that should be applied on every level

// zoomLevelToStart: zoom level to start running functions (inclusive)

// zoomLevelToStop: zoom level to stop running functions (inclusive)

//A cluster will cover at most this many pixels from its center

//Animated versions here

//Cludge for Icon, we pretend to be an icon for performance

//Default functionality

//Enqueue code to fire after the marker expand/contract has happened

//Force a browser layout of stuff in the map

//Gets the maps visible bounds expanded in each direction by the size of the screen (so the user cannot see an area we do not cover in one pan)

//If the given layer is currently being spiderfied then we unspiderfy it so it isn't on the map anymore etc

//Increase to increase the distance away that spiderfied markers appear from the center

//Internal function for removing a marker from everything.

//Merge and split any existing clusters that are too big or small

//Non Animated versions of everything

//On zoom start we add a zoomanim handler so that we are guaranteed to be last (after markers are animated)

//Options to pass to the L.Polygon constructor

//Override FeatureGroup.getBounds as it doesn't work

//Override L.Evented.fire

//Override L.Evented.listens

//Overrides FeatureGroup.onAdd

//Overrides FeatureGroup.onRemove

//Overrides LayerGroup.eachLayer

//Overrides LayerGroup.getLayer, WARNING: Really bad performance

//Overrides LayerGroup.getLayers

//Recursively retrieve all child markers of this cluster

//Remove the given object from the given array

//Removes all layers from the MarkerClusterGroup

//Returns the count of how many child markers we have

//Returns true if the given layer is in this MarkerClusterGroup

//Returns true if the object was found

//Returns true if we are the parent of only one cluster and that cluster is the same as us

//Run the given functions recursively to this and child clusters

//Set our markers position as given and add it to the map

//Shared animation code

//Takes an array of markers and adds them in bulk

//Takes an array of markers and removes them in bulk

//The MarkerCluster currently spiderfied (if any)

//This means we can define the animation they do rather than Markers doing an animation to their actual location

//Whether to animate adding markers after adding the MarkerClusterGroup to the map

//Zoom down to show the given layer (spiderfying if necessary) then calls the callback

//Zoom to the minimum of showing all of the child markers, or the extents of this cluster

//Zoom: Zoom to start adding at (Pass this._maxZoom to start at the bottom)

//dontUpdateMap: set to true if you will handle updating the map manually (for bulk functions)

//exceptBounds: If set, don't remove any markers/clusters in it

//related to circumference of circle

//related to size of spiral (experiment!)

//show spiral instead of circle from this marker count upwards.
